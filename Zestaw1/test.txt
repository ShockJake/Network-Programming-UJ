g++ (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0
Copyright (C) 2019 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

/*
    Zaimplementuj program kopiujący dane z pliku do pliku przy pomocy powyższych funkcji.
    Zakładamy, że nazwy plików są podawane przez użytkownika jako argumenty programu (tzn. będą dostępne w tablicy argv).
    Zwróć szczególną uwagę na obsługę błędów — każde wywołanie funkcji we-wy musi być opatrzone testem sprawdzającym,
    czy zakończyło się ono sukcesem, czy porażką.

    Funkcje POSIX zwracają -1 aby zasygnalizować wystąpienie błędu,
    i dodatkowo zapisują w globalnej zmiennej errno kod wskazujący przyczynę wystąpienia błędu (na dysku nie ma pliku o takiej nazwie,
    brak wystarczających praw dostępu, itd.).
    Polecam Państwa uwadze pomocniczą funkcję perror, która potrafi przetłumaczyć ten kod na zrozumiały dla człowieka komunikat i wypisać go na ekranie.
*/

#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#define MAX_SIZE 512 // Maksymalny rozmiar buffora

// Funkcja dla odczytu z pliku
void readFile(const char *fileName, char *buf)
{
    int file = open(fileName, O_RDONLY); // Otwieranie pliku, jeśli nie uda się to rzuca pomyłkę i wychodzi z programu
    if (file == -1)
    {
        perror("Can't open the file");
        _exit(-1);
    }

    size_t nbyte = sizeof(buf); // Zadanie ilości bajtów dla czytania.
    int bufferSize = 0;         // Zmienna dla sprawdzania stanu funkcji

    printf("Reading from a file...\n");
    while ((bufferSize = read(file, buf, nbyte)) != 0) // Odczyt pliku
    {
        if (bufferSize == -1) // Jeśli nie potrafi odczytać plik rzuca pomyłkę
        {

            perror("Can't read the file");
            close(file);
            _exit(-1);
        }
    }
    close(file); // Zamykanie pliku.
}

// Zapisanie danych do pliku
void writeToFile(char *data)
{
    mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH; // Dodanie dozwolień do wszystkich
    char *pathname = "/Projects/NetProg/Zadanie1/new_file.txt";   // Ścieżka i imie pliku

    int file = open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode); // Otwieranie pliku
    // jeśli nie uda się to rzuca pomyłkę i wychodzi z programu
    if (file == -1)
    {
        perror("Can't create the file");
        _exit(-1);
    }

    size_t nbyte = sizeof(data[0]); // Zadanie ilości bajtów dla czytania.
    int buffSize = 0;               // Zmienna dla sprawdzania stanu funkcji

    printf("\n Writing to a file...\n");

    while ((buffSize = write(file, data, nbyte)) != 0) // Zapisanie danych do pliku
    {
        if (buffSize == -1) // Jeśli nie potrafi odczytać plik rzuca pomyłkę
        {
            perror("Can't write the file");
            close(file);
            _exit(-1);
        }
    }
    close(file); // Zamykanie pliku
}

int main(int argc, char const *argv[])
{
    printf("\nProgram to write data from a file to another file\n");
    printf("\n\nFile name %s\n", argv[1]);

    char input;
    char data[MAX_SIZE];

    readFile(argv[1], data);
    writeToFile(data);

    printf("\n Do you want to display data? [Y/n]\n");

    while (scanf("%c", &input))
    {
        if (input == 'y' || input == 'y')
        {
            printf("%s", data);
        }
        else if (input == 'n' || input == 'N')
        {
            break;
        }
        else
        {
            printf("input error, Do you want to display data? [Y/n]\n");
        }
    }

    return 0;
}
